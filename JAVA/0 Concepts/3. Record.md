## Record

Passing immutable data between objects is one of the most common, but mundane tasks in many Java applications.
Commonly, we write classes to simply hold data, such as database results, query results, or information from a service.

In many cases, this data is immutable, since immutability ensures the validity of the data without synchronization.

To accomplish this, we create data classes with the following:

1.  private, final field for each piece of data
2.  getter for each field
3.  public constructor with a corresponding argument for each field
4.  equals method that returns true for objects of the same class when all fields match
5.  hashCode method that returns the same value when all fields match
6.  toString method that includes the name of the class and the name of each field and its corresponding value

```java
public class Person {

    private final String name;
    private final String address;

    public Person(String name, String address) {
        this.name = name;
        this.address = address;
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, address);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        } else if (!(obj instanceof Person)) {
            return false;
        } else {
            Person other = (Person) obj;
            return Objects.equals(name, other.name)
              && Objects.equals(address, other.address);
        }
    }

    @Override
    public String toString() {
        return "Person [name=" + name + ", address=" + address + "]";
    }

    // standard getters
}
```

While this accomplishes our goal, there are two problems with it:

Thereâ€™s a lot of boilerplate code
We obscure the purpose of our class: to represent a person with a name and address

While IDEs can automatically generate many of these classes, they fail to automatically update our classes when we add a new field.
For example, if we add a new field, we have to update our equals method to incorporate this field.

In the second case, the extra code obscures that our class is simply a data class that has two String fields, name and address.

A better approach would be to explicitly declare that our class is a data class.

As of `JDK 14`, we can replace our repetitious data classes with records.
`Records are immutable data classes that require only the type and name of fields.`
The equals, hashCode, and toString methods, as well as the private, final fields and public constructor, are generated by the Java compiler.

```java
public record Person (String name, String address) {}
```

### Static Variables & Methods

As with regular Java classes, we can also include static variables and methods in our records.

We declare static variables using the same syntax as a class:

```java
public record Person(String name, String address) {
    public static String UNKNOWN_ADDRESS = "Unknown";
}
```

```java
public record Person(String name, String address) {
    public static Person unnamed(String address) {
        return new Person("Unnamed", address);
    }
}
```

```java
Person.UNKNOWN_ADDRESS
Person.unnamed("100 Linda Ln.");
```
